<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>DJ-Style Radial SVG Animator</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: #111;
      font-family: 'Courier New', monospace;
      color: #0f0;
    }

    #animationContainer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    .monad {
      position: absolute;
      display: block;
      transform-origin: center center;
      pointer-events: none;
    }

    .control-panel {
      position: fixed;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid #0f0;
      border-radius: 6px;
      padding: 12px;
      box-shadow: 0 0 10px #0f0;
      z-index: 1000;
      width: 240px;
    }

    #radialControls {
      top: 10px;
      left: 10px;
    }

    #audioControls {
      top: 10px;
      right: 10px;
    }

    .control-panel h3 {
      margin: 0 0 8px;
      font-size: 16px;
      text-align: center;
      text-decoration: underline;
    }

    .control-panel label {
      display: block;
      font-size: 12px;
      margin: 6px 0 2px;
    }

    .control-panel input[type="range"],
    .control-panel input[type="number"],
    .control-panel input[type="color"] {
      width: 100%;
    }

    .control-panel input[type="checkbox"] {
      margin-right: 6px;
    }

    .control-panel .small {
      font-size: 11px;
      color: #555;
    }

    .rangeWrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: auto;
      flex: 0;
      padding: 1rem;
      gap: 1.1rem;
    }

    input[type=range] {
      display: flex;
      width: 25rem;
      height: 1.5rem;
      -webkit-appearance: none;
      background: linear-gradient(180deg, #8f813d, #706048, #7A702A);
      border-radius: 1.5rem;
      box-shadow: 0 3px 2px -1px rgba(255, 255, 255, 0.25) inset, 0 0 10px 0 rgba(0, 0, 0, 0.5), 0 0 10px 2px rgba(0, 0, 0, 0.25), 0 8px 4px -3px rgba(0, 0, 0, 0.15);
    }

    input[type=range]::-webkit-slider-runnable-track,
    input[type=range]::-moz-range-track {
      background: #222;
      width: 24rem;
      height: 0.25rem;
      border-radius: 3rem;
      cursor: pointer;
      box-shadow: 0 1px 1px 0 rgba(255, 255, 255, 0.25), 0 2px 2px 0 rgba(255, 255, 255, 0.15);
      border: 1px solid rgba(0, 0, 0, 0.25);
    }

    input[type=range]::-webkit-slider-runnable-track {
      background: #222;
      width: 24rem;
      height: 0.25rem;
      margin: 0 0.5rem;
    }

    input[type=range]::-webkit-slider-thumb,
    input[type=range]::-moz-range-thumb {
      width: 1.8rem;
      height: 1.8rem;
      background: radial-gradient(#444 45%, #555 50%, #222 55%, #8C7853 57.5%, #8C7853 100%), conic-gradient(#4b4b4b 10deg, #777 45deg, #5b5b6b 70deg, #9f9f9f 105deg, #444 140deg, #AAA 185deg, #666 210deg, #999 245deg, #777 285deg, #9f9f9f 320deg, #4b4b4b);
      background-blend-mode: overlay;
      box-shadow: 0 0 1px 1px rgba(255, 255, 255, 0.35) inset, 0 1px 1px 1px rgba(255, 255, 255, 0.25) inset, 0 0 2px 2px rgba(0, 0, 0, 0.15) inset, 0 1px 1px 1px rgba(0, 0, 0, 0.35), 0 3px 2px 1px rgba(0, 0, 0, 0.25), 0 6px 4px 3px rgba(0, 0, 0, 0.15);
      border-radius: 1.5rem;
      cursor: pointer;
    }

    input[type=range]::-webkit-slider-thumb {
      transform: translatey(-0.8rem);
      width: 1.8rem;
      height: 1.8rem;
      background: radial-gradient(#444 45%, #555 50%, #222 55%, #8C7853 57.5%, #8C7853 100%), conic-gradient(#4b4b4b 10deg, #777 45deg, #5b5b6b 70deg, #9f9f9f 105deg, #444 140deg, #AAA 185deg, #666 210deg, #999 245deg, #777 285deg, #9f9f9f 320deg, #4b4b4b);
      background-blend-mode: overlay;
      box-shadow: 0 0 1px 1px rgba(255, 255, 255, 0.35) inset, 0 1px 1px 1px rgba(255, 255, 255, 0.25) inset, 0 0 2px 2px rgba(0, 0, 0, 0.15) inset, 0 1px 1px 1px rgba(0, 0, 0, 0.35), 0 3px 2px 1px rgba(0, 0, 0, 0.25), 0 6px 4px 3px rgba(0, 0, 0, 0.15);
      border-radius: 1.5rem;
      cursor: pointer;
      -webkit-appearance: none;
    }

    datalist {
      display: flex;
      justify-content: space-between;
      color: hsl(45, 80%, 35%);
      width: 25rem;
      line-height: 1.75;
      transform: translatey(0.8rem);
    }

    datalist>option {
      z-index: 1;
      display: flex;
      position: relative;
      padding: 0 0.25rem;
      border: 1px solid hsl(45, 80%, 35%);
      border-radius: 0.5rem;
      text-shadow: 0 1px 1px 0 rgba(0, 0, 0, 0.25);
      box-shadow: 0 1px 1px 0 rgba(0, 0, 0, 0.25);
    }

    datalist>option:before {
      content: '';
      display: inline-block;
      position: relative;
      left: 50%;
      height: 1rem;
      width: 1px;
      background: hsl(45, 80%, 35%);
      transform: translatey(-100%);
    }
  </style>
</head>

<body>

  <!-- Animation canvas -->
  <div id="animationContainer"></div>
  <div id="svgContainer" style="display:none;"></div>

  <!-- Top: Radial controls -->
  <div id="radialControls" class="control-panel">
    <h3>üéõÔ∏è Animation Controls</h3>
    <label>Upload SVG or PNG:</label>
    <div id="dropZone" style="border: 2px dashed #0f0; padding: 20px; text-align: center; margin-bottom: 10px;">
      Drag & Drop Here
    </div>

    <input type="file" id="svgUpload" accept=".svg,.png" style="display:inline-block; width:auto;">


    <label>Radial Repeats:</label>
    <input type="number" id="repeatCount" min="1" max="64">

    <label>Base Size (px):</label>
    <input type="range" id="sizeSlider" min="50" max="500">

    <label>Radius (px):</label>
    <input type="range" id="radiusSlider" min="0" max="500">

    <label>Center X (%):</label>
    <input type="range" id="posXSlider" min="0" max="100">

    <label>Center Y (%):</label>
    <input type="range" id="posYSlider" min="0" max="100">

    <label>Composite Speed:</label>
    <input type="range" id="compSpeed" min="-0.1" max="0.1" step="0.001">

    <label>Individual Speed:</label>
    <input type="range" id="indSpeed" min="-0.2" max="0.2" step="0.001">

    <label>Breathing Rate:</label>
    <input type="range" id="breathRate" min="0" max="0.2" step="0.001">

    <label>Breathing Amp:</label>
    <input type="range" id="breathAmp" min="0" max="1" step="0.01">

    <label>Background:</label>
    <input type="color" id="bgColorPicker">

    <label><input type="checkbox" id="colorShiftToggle"> Hue-Shift</label>
    <label>Hue Speed:</label>
    <input type="range" id="hueSpeed" min="0" max="5" step="0.1">

    <label>Hue Drift Speed:</label>
    <input type="range" id="hueDriftSpeed" min="-2" max="2" step="0.01" value="0.2">

    <label><input type="checkbox" id="breathToggle"> Enable Breathing</label>

  </div>

  <!-- Bottom: Audio controls -->
  <div id="audioControls" class="control-panel">
    <h3>üéß Audio Controls</h3>
    <label><input type="checkbox" id="audioToggle"> Audio Reactive</label>
    <span class="small">(allow mic when prompted)</span>

    <label>Sensitivity:</label>
    <input type="range" id="audioSens" min="0" max="5" step="0.1">

    <label>Bass Boost:</label>
    <input type="range" id="bassBoost" min="0" max="5" step="0.1">

    <label>Mid Boost:</label>
    <input type="range" id="midBoost" min="0" max="5" step="0.1">

    <label>Treble Boost:</label>
    <input type="range" id="trebBoost" min="0" max="5" step="0.1">

    <label>Max Radius Mod (px):</label>
    <input type="range" id="audioModMax" min="0" max="500" step="10">

  </div>

  <script>
    // === Globals & DOM refs ===
    let sourceSvg = null, vbW = 1, vbH = 1;
    let clones = [], compAng = 0, breathAng = 0, hueAng = 0, running = false;

    const svgUpload = document.getElementById('svgUpload');
    const repeatCountIn = document.getElementById('repeatCount');
    const sizeSlider = document.getElementById('sizeSlider');
    const radiusSlider = document.getElementById('radiusSlider');
    const compSpeedIn = document.getElementById('compSpeed');
    const indSpeedIn = document.getElementById('indSpeed');
    const breathRateIn = document.getElementById('breathRate');
    const breathAmpIn = document.getElementById('breathAmp');
    const bgPicker = document.getElementById('bgColorPicker');
    const hueToggle = document.getElementById('colorShiftToggle');
    const hueSpeedIn = document.getElementById('hueSpeed');
    const hueDriftSpeedIn = document.getElementById('hueDriftSpeed');
    const breathToggle = document.getElementById('breathToggle');

    const audioToggle = document.getElementById('audioToggle');
    const audioSensIn = document.getElementById('audioSens');
    const bassBoostIn = document.getElementById('bassBoost');
    const midBoostIn = document.getElementById('midBoost');
    const trebBoostIn = document.getElementById('trebBoost');
    const audioModMaxIn = document.getElementById('audioModMax');

    const animContainer = document.getElementById('animationContainer');
    const svgContainer = document.getElementById('svgContainer');

    const SETTINGS_KEY = 'radialAnimatorSettings';

    // sensible defaults
    const D = {
      repeats: 12,
      size: 150,
      radius: 200,
      posX: 50,
      posY: 50,
      compSpeed: 0.005,
      indSpeed: 0.05,
      breathRate: 0.02,
      breathAmp: 0.1,
      bgColor: '#111111',
      hueMode: false,
      hueSpeed: 0.2,
      hueDriftSpeed: 0.2,
      audioSens: 1,
      bassBoost: 1,
      midBoost: 1,
      trebBoost: 1,
      audioModMax: 100,
      audioReactive: false,
      breathEnabled: false,
    };

    function loadSettings() {
      const saved = localStorage.getItem(SETTINGS_KEY);
      if (!saved) return;
      try {
        const obj = JSON.parse(saved);
        Object.assign(D, obj);
      } catch (e) {
        console.warn('Failed to parse saved settings', e);
      }
    }

    function saveSettings() {
      const obj = {
        repeats: +repeatCountIn.value,
        size: +sizeSlider.value,
        radius: +radiusSlider.value,
        compSpeed: +compSpeedIn.value,
        indSpeed: +indSpeedIn.value,
        breathRate: +breathRateIn.value,
        breathAmp: +breathAmpIn.value,
        bgColor: bgPicker.value,
        hueMode: hueToggle.checked,
        hueSpeed: +hueSpeedIn.value,
        audioSens: +audioSensIn.value,
        bassBoost: +bassBoostIn.value,
        midBoost: +midBoostIn.value,
        trebBoost: +trebBoostIn.value,
        audioModMax: +audioModMaxIn.value,
        audioReactive: audioToggle.checked,
        hueDriftSpeed: +hueDriftSpeedIn.value,
        breathEnabled: breathToggle.checked
      };
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(obj));
    }

    function setDefaults() {
      repeatCountIn.value = D.repeats;
      sizeSlider.value = D.size;
      radiusSlider.value = D.radius;
      compSpeedIn.value = D.compSpeed;
      indSpeedIn.value = D.indSpeed;
      breathRateIn.value = D.breathRate;
      breathAmpIn.value = D.breathAmp;
      bgPicker.value = D.bgColor;
      hueToggle.checked = D.hueMode;
      hueSpeedIn.value = D.hueSpeed;
      audioSensIn.value = D.audioSens;
      bassBoostIn.value = D.bassBoost;
      midBoostIn.value = D.midBoost;
      trebBoostIn.value = D.trebBoost;
      audioModMaxIn.value = D.audioModMax;
      audioToggle.checked = D.audioReactive;
      hueDriftSpeedIn.value = D.hueDriftSpeed;
      breathToggle.checked = D.breathEnabled;
      document.body.style.background = D.bgColor;
    }

    function attachSaveListeners() {
      const inputs = document.querySelectorAll('input');
      inputs.forEach(input => {
        input.addEventListener('input', saveSettings);
        input.addEventListener('change', saveSettings);
      });
    }

    // === Your original event listeners and animate loop ===

    bgPicker.addEventListener('input', e => {
      document.documentElement.style.background = e.target.value;
    });

    svgUpload.addEventListener('change', e => {
      const f = e.target.files[0];
      if (!f) return;
      handleFile(f)
    });

    const dropZone = document.getElementById('dropZone');

    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.style.background = 'rgba(0,255,0,0.2)';
    });

    dropZone.addEventListener('dragleave', () => {
      dropZone.style.background = 'transparent';
    });

    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.style.background = 'transparent';
      const file = e.dataTransfer.files[0];
      if (file) {
        handleFile(file);
      }
    });

    // Reusable file handler (called by both input and drag-and-drop)
    function handleFile(f) {
      const ext = f.name.split('.').pop().toLowerCase();
      const r = new FileReader();

      r.onload = ev => {
        if (ext === 'svg') {
          const doc = new DOMParser().parseFromString(ev.target.result, 'image/svg+xml');
          const svg = doc.querySelector('svg');
          if (!svg) return alert('Invalid SVG!');
          svgContainer.innerHTML = '';
          svgContainer.appendChild(svg);

          sourceSvg = svg;
          const vb = svg.viewBox.baseVal;
          vbW = vb.width || svg.clientWidth;
          vbH = vb.height || svg.clientHeight;

          // ‚úÖ Save SVG text into localStorage
          localStorage.setItem('savedFileType', 'svg');
          localStorage.setItem('savedFileData', ev.target.result);

        } else if (ext === 'png') {
          const img = new Image();
          img.src = ev.target.result;
          img.style.display = 'block';
          svgContainer.innerHTML = '';
          svgContainer.appendChild(img);

          sourceSvg = img;
          vbW = img.width || 100;
          vbH = img.height || 100;

          // ‚úÖ Save PNG Data URL into localStorage
          localStorage.setItem('savedFileType', 'png');
          localStorage.setItem('savedFileData', ev.target.result);
        } else {
          alert('Unsupported file type!');
          return;
        }

        compAng = breathAng = hueAng = 0;
        setDefaults();
        buildMonads();
        if (!running) {
          running = true;
          requestAnimationFrame(animate);
        }
      };

      if (ext === 'svg') {
        r.readAsText(f);
      } else if (ext === 'png') {
        r.readAsDataURL(f);
      } else {
        alert('Unsupported file type!');
      }
    }

    function loadSavedFile() {
      const type = localStorage.getItem('savedFileType');
      const data = localStorage.getItem('savedFileData');

      if (!type || !data) return;

      svgContainer.innerHTML = '';

      if (type === 'svg') {
        const doc = new DOMParser().parseFromString(data, 'image/svg+xml');
        const svg = doc.querySelector('svg');
        if (!svg) return;

        svgContainer.appendChild(svg);
        sourceSvg = svg;
        const vb = svg.viewBox.baseVal;
        vbW = vb.width || svg.clientWidth;
        vbH = vb.height || svg.clientHeight;
      } else if (type === 'png') {
        const img = new Image();
        img.src = data;
        img.style.display = 'block';
        svgContainer.appendChild(img);
        sourceSvg = img;
        vbW = img.width || 100;
        vbH = img.height || 100;
      }

      compAng = breathAng = hueAng = 0;
      setDefaults();
      buildMonads();
      if (!running) {
        running = true;
        requestAnimationFrame(animate);
      }
    }

    repeatCountIn.addEventListener('input', () => {
      if (sourceSvg) buildMonads();
    });

    function buildMonads() {
      clones = []; animContainer.innerHTML = '';
      const n = parseInt(repeatCountIn.value, 10);
      for (let i = 0; i < n; i++) {
        const c = sourceSvg.cloneNode(true);
        c.removeAttribute('style'); c.style.display = 'block';
        c.classList.add('monad');
        animContainer.appendChild(c);
        clones.push({ el: c, ang: 0 });
      }
    }

    let audioCtx, analyser, freqData;
    audioToggle.addEventListener('change', async () => {
      if (audioToggle.checked && !audioCtx) {
        try {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          analyser = audioCtx.createAnalyser();
          analyser.fftSize = 2048;
          freqData = new Uint8Array(analyser.frequencyBinCount);
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const src = audioCtx.createMediaStreamSource(stream);
          src.connect(analyser);
        } catch (err) {
          alert('Mic access denied');
          audioToggle.checked = false;
        }
      }
    });

    function animate() {
      // live values
      const baseSize = +sizeSlider.value;
      const baseRad = +radiusSlider.value;
      const cx = 0.5 * animContainer.clientWidth;
      const cy = 0.5 * animContainer.clientHeight;
      const compSpd = +compSpeedIn.value;
      const indSpd = +indSpeedIn.value;
      const bRate = +breathRateIn.value;
      const bAmp = +breathAmpIn.value;
      const bg = bgPicker.value;
      const hueOn = hueToggle.checked;
      const hueSpd = +hueSpeedIn.value;

      // audio params
      const audioOn = audioToggle.checked && analyser;
      const sens = +audioSensIn.value;
      const bassB = +bassBoostIn.value;
      const midB = +midBoostIn.value;
      const trebB = +trebBoostIn.value;
      const maxMod = +audioModMaxIn.value;

      document.body.style.background = bg;
      compAng += compSpd;
      breathAng += bRate;
      if (hueOn) {
        const driftSpeed = +hueDriftSpeedIn.value;
        hueAng = (hueAng + driftSpeed) % 360;
      }

      // get audio level
      let audioLevel = 0;
      if (audioOn) {
        analyser.getByteFrequencyData(freqData);
        const len = freqData.length;
        const third = Math.floor(len / 3);
        const bass = freqData.slice(0, third).reduce((a, v) => a + v, 0) / third;
        const mid = freqData.slice(third, 2 * third).reduce((a, v) => a + v, 0) / third;
        const treb = freqData.slice(2 * third).reduce((a, v) => a + v, 0) / (len - 2 * third);
        const totalWeight = bassB + midB + trebB;
        const weighted = bass * bassB + mid * midB + treb * trebB;
        audioLevel = (weighted / 255 / totalWeight) * sens;
      }

      const n = clones.length;
      const step = Math.PI * 2 / n;
      clones.forEach((c, i) => {
        // dynamic radius = base + audio pulse
        const rad = baseRad + audioLevel * maxMod;

        const ang = i * step + compAng;
        const x = cx + rad * Math.cos(ang);
        const y = cy + rad * Math.sin(ang);

        c.ang += indSpd;
        const scale = 1 + bAmp * Math.sin(breathAng + i * step);

        const wpx = baseSize * scale;
        const hpx = baseSize * scale * (vbH / vbW);

        // apply
        c.el.style.width = wpx + 'px';
        c.el.style.height = hpx + 'px';
        c.el.style.left = (x - wpx / 2) + 'px';
        c.el.style.top = (y - hpx / 2) + 'px';
        c.el.style.transform = `rotate(${c.ang}rad)`;

        if (hueOn) {
          const shift = (hueAng + i * (360 / n)) % 360;
          let brightness = 1;
          let saturation = 1;

          // Breathing modulation
          if (breathToggle.checked) {
            const breath = (Math.sin(performance.now() * 0.001) + 1) / 2; // oscillates 0 to 1
            brightness = 0.75 + 0.25 * breath; // brightness from 0.75 to 1
            saturation = 0.75 + 0.5 * breath;  // saturation from 0.75 to 1.25
          }

          c.el.style.filter = `
            brightness(${brightness})
            saturate(${saturation})
            hue-rotate(${shift}deg)
          `;
        } else {
          c.el.style.filter = '';
        }
      });

      requestAnimationFrame(animate);
    }

    // === INIT ===
    loadSettings();
    setDefaults();
    loadSavedFile();
    attachSaveListeners();

  </script>
</body>

</html>
